{"meta":{"title":"PhoenixGS","subtitle":null,"description":null,"author":"PhoenixGS","url":"http://phoenixgs.github.io"},"pages":[],"posts":[{"title":"BZOJ 1009 [HNOI2008]GT考试","slug":"BZOJ-1009","date":"2018-04-09T02:30:51.000Z","updated":"2018-04-09T15:42:12.328Z","comments":true,"path":"2018/04/09/BZOJ-1009/","link":"","permalink":"http://phoenixgs.github.io/2018/04/09/BZOJ-1009/","excerpt":"题意有多少个n位数字，其中没有出现过A","text":"题意有多少个n位数字，其中没有出现过A 题解很simple的一个DP就是f[i][j]表示现在字符串长度为i，匹配到A的KMP的状态为j，然后用矩阵乘法优化一下就好了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;cstring&gt;int n, m, M;char s[1000];int nextx[1000];int mat[22][22], ans[22][22], z[22][22];int anss;void getnextx()&#123; int j = 0; for (int i = 2; i &lt;= m; i++) &#123; while (j &amp;&amp; s[j + 1] != s[i]) &#123; j = nextx[j]; &#125; if (s[j + 1] == s[i]) &#123; j++; &#125; nextx[i] = j; &#125;&#125;void mul(int x[22][22], int y[22][22])&#123; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; z[i][j] = 0; &#125; &#125; for (int k = 0; k &lt; m; k++) &#123; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; z[i][j] = (z[i][j] + (long long)x[i][k] * y[k][j] % M) % M; &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; x[i][j] = z[i][j]; &#125; &#125;&#125;int main()&#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;M); scanf(\"%s\", s + 1); getnextx(); for (int i = 0; i &lt; m; i++) &#123; for (char j = '0'; j &lt;= '9'; j++) &#123; int tmp = i; while (tmp &amp;&amp; s[tmp + 1] != j) &#123; tmp = nextx[tmp]; &#125; if (s[tmp + 1] == j) &#123; tmp++; &#125; if (tmp != m) &#123; mat[i][tmp]++; &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; ans[i][i] = 1; &#125; while (n) &#123; if (n &amp; 1) &#123; mul(ans, mat); &#125; mul(mat, mat); n &gt;&gt;= 1; &#125; anss = 0; for (int i = 0; i &lt; m; i++) &#123; anss = (anss + ans[0][i]) % M; &#125; printf(\"%d\\n\", anss); return 0;&#125;","categories":[],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://phoenixgs.github.io/tags/KMP/"}]},{"title":"BZOJ 3670 [Noi2014]动物园","slug":"BZOJ-3670","date":"2018-04-09T02:21:11.000Z","updated":"2018-04-09T14:59:45.459Z","comments":true,"path":"2018/04/09/BZOJ-3670/","link":"","permalink":"http://phoenixgs.github.io/2018/04/09/BZOJ-3670/","excerpt":"题意 我现在希望求出一个更强大num数组一一对于字符串S的前i个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作num[i]。 然后输出$ \\Pi _ {i = 1} ^ L (num[i] + 1) $","text":"题意 我现在希望求出一个更强大num数组一一对于字符串S的前i个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作num[i]。 然后输出$ \\Pi _ {i = 1} ^ L (num[i] + 1) $ 题解这道题十分显然，求出nextx数组的同时求出自动机状态里的集合大小，然后枚举区间的右端点，满足题意不重叠的条件之后就可以算答案了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int M = 1000000007;int T;int ans;char s[2000000];int n;int nextx[2000000];int k[2000000];int main()&#123; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%s\", s + 1); n = strlen(s + 1); k[0] = 0; k[1] = 1; int j = 0; for (int i = 2; i &lt;= n; i++) &#123; while (j &amp;&amp; s[j + 1] != s[i]) &#123; j = nextx[j]; &#125; if (s[j + 1] == s[i]) &#123; j++; &#125; nextx[i] = j; k[i] = k[j] + 1; &#125; j = 0; ans = 1; for (int i = 1; i &lt;= n; i++) &#123; while (j &amp;&amp; s[j + 1] != s[i]) &#123; j = nextx[j]; &#125; if (s[j + 1] == s[i]) &#123; j++; &#125; while (j &gt; i / 2) &#123; j = nextx[j]; &#125; ans = (long long)ans * (k[j] + 1) % M; &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://phoenixgs.github.io/tags/KMP/"}]},{"title":"HDU 2594 Simpsons’ Hidden Talents","slug":"HDU-2594","date":"2018-04-08T13:00:39.000Z","updated":"2018-04-09T14:47:12.320Z","comments":true,"path":"2018/04/08/HDU-2594/","link":"","permalink":"http://phoenixgs.github.io/2018/04/08/HDU-2594/","excerpt":"题意求出最大的k使s1长度为k的前缀等于s2长度为k的后缀","text":"题意求出最大的k使s1长度为k的前缀等于s2长度为k的后缀 题解扩展KMP模版题，求出extend之后，从前往后枚举位置i，只要往后extend[i]能到末尾就输出答案 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;char s[100000], t[100000];int n, m;int nextx[100000], extend[100000];int ans;void getnextx()&#123; int pos = -1, last = -1; for (int i = 2; i &lt;= m; i++) &#123; int k = (pos == -1 || i &gt; last) ? 0 : std::min(nextx[i - pos + 1], last - i + 1); while (k + 1 &lt;= n &amp;&amp; t[i + k] == t[k + 1]) &#123; k++; &#125; nextx[i] = k; if (i + nextx[i] - 1 &gt; last) &#123; pos = i; last = i + nextx[i] - 1; &#125; &#125;&#125;int main()&#123; while (scanf(\"%s%s\", s + 1, t + 1) == 2) &#123; n = strlen(s + 1); m = strlen(t + 1); getnextx(); int pos = -1, last = -1; for (int i = 1; i &lt;= m; i++) &#123; int k = (pos == -1 || i &gt; last) ? 0 : std::min(nextx[i - pos + 1], last - i + 1); while (k + 1 &lt;= n &amp;&amp; i + k &lt;= m &amp;&amp; t[i + k] == s[k + 1]) &#123; k++; &#125; extend[i] = k; if (i + extend[i] - 1 &gt; last) &#123; pos = i; last = i + extend[i] - 1; &#125; &#125; ans = 0; for (int i = 1; i &lt;= m; i++) &#123; if (i + extend[i] - 1 == m) &#123; ans = extend[i]; break; &#125; &#125; if (ans) &#123; for (int i = 1; i &lt;= ans; i++) &#123; printf(\"%c\", s[i]); &#125; printf(\" \"); &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"扩展KMP","slug":"扩展KMP","permalink":"http://phoenixgs.github.io/tags/扩展KMP/"}]},{"title":"Hello World","slug":"Hello-World","date":"2016-05-29T03:07:22.000Z","updated":"2018-04-09T16:24:43.180Z","comments":true,"path":"2016/05/29/Hello-World/","link":"","permalink":"http://phoenixgs.github.io/2016/05/29/Hello-World/","excerpt":"","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-ZVRbITCX\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"https://phoenixgs-1253902147.cos.ap-chengdu.myqcloud.com/%E8%8C%B6%E7%90%86%E7%90%86%2C%E5%8F%8C%E7%AC%99%20-%20%E7%AB%A5%E8%AF%9D%E9%95%87%EF%BC%88Cover%20%E6%9A%97%E6%9D%A0%EF%BC%89.mp3\", author: \"undefined\", url: \"undefined\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 123456789#include &lt;cstdio&gt;int main()&#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); printf(\"%d\\n\", x + y); return 0;&#125;","categories":[],"tags":[]}]}